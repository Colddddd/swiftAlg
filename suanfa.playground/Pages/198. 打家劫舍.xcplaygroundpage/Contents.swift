//: [Previous](@previous)

import Foundation
/**
 198. 打家劫舍
 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
 
 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
 
 示例 1：
 
 输入：[1,2,3,1]
 输出：4
 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
 偷窃到的最高金额 = 1 + 3 = 4 。
 示例 2：
 
 输入：[2,7,9,3,1]
 输出：12
 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
 偷窃到的最高金额 = 2 + 9 + 1 = 12 。
 
 
 提示：
 
 0 <= nums.length <= 100
 0 <= nums[i] <= 400
 */

/**
 相邻不可选，跨位可以，肯定会存在重复子问题。 从前往后 遍历，还是从后往前存？
 
 递归 + dp ？
 


 题解: 每种状态都存在  偷与不偷，以此求出 状态转移方程

 偷吗:    2  7  9  3  1
 要偷:    2  7  11 7  12
 不偷:    0  2  7  11 11

 r[0]  = 0  r[i]  = nr[i-1] + i
 nr[0] = 0  nr[i] = max(nr[i-1], r[i-1])

 即：当前数 i偷，则上一个 i-1 不能偷，也就是不能偷的 res  + 当前 value
 当前数 不偷，即 i- 1 可以偷，也可以不偷， 即2个方式的最大值
 */

class Solution {
    func rob(_ nums: [Int]) -> Int {
        var r = 0, nr = 0
        for i in  0..<nums.count {
            let pre = max(r, nr)
            r = nr + nums[i]
            nr = pre
        }
        return max(r, nr)
    }
}

let s = Solution()
print(s.rob([2,7,9,3,1]))

